/* * Copyright (c) 2015 Samsung Electronics Co., Ltd. All rights reserved.  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that  * the following conditions are met: *  *     * Redistributions of source code must retain the above copyright notice,  *       this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright notice,  *       this list of conditions and the following disclaimer in the documentation and/or  *       other materials provided with the distribution.  *     * Neither the name of Samsung Electronics Co., Ltd. nor the names of its contributors may be used to endorse *       or promote products derived from this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */package com.samsung.android.sdk.accessory.example.helloaccessory.provider;import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Calendar;import java.util.GregorianCalendar;import java.util.List;import java.util.StringTokenizer;import android.app.ActivityManager;import android.content.Context;import android.content.Intent;import android.database.Cursor;import android.database.sqlite.SQLiteDatabase;import android.database.sqlite.SQLiteException;import android.os.*;import android.text.ClipboardManager;import android.util.Log;import com.samsung.android.sdk.SsdkUnsupportedException;import com.samsung.android.sdk.accessory.*;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;public class ProviderService extends SAAgent {    private static final String TAG = "HelloAccessory(P)";    private static final int HELLOACCESSORY_CHANNEL_ID = 104;    private static final Class<ServiceConnection> SASOCKET_CLASS = ServiceConnection.class;    private final IBinder mBinder = new LocalBinder();    private ServiceConnection mConnectionHandler = null;    private ArrayList<String> cmdList = new ArrayList<String>();    public int delay_time = 0;    Handler mHandler = new Handler();    private MySQLiteOpenHelper helper;    String dbName = "st_file.db";    private SQLiteDatabase db;    int dbVersion = 1; // 데이터베이스 버전    public ProviderService() {        super(TAG, SASOCKET_CLASS);    }    RbPreference pref;    @Override    public void onCreate() {        super.onCreate();        pref = new RbPreference(getApplicationContext());        helper = new MySQLiteOpenHelper(                this,  // 현재 화면의 제어권자                dbName,// db 이름                null,  // 커서팩토리-null : 표준커서가 사용됨                dbVersion);       // 버전        SA mAccessory = new SA();        try {            mAccessory.initialize(this);        } catch (SsdkUnsupportedException e) {            // try to handle SsdkUnsupportedException            if (processUnsupportedException(e) == true) {                return;            }        } catch (Exception e1) {            e1.printStackTrace();            stopSelf();        }    }    @Override    public IBinder onBind(Intent intent) {        return mBinder;    }    @Override    protected void onFindPeerAgentResponse(SAPeerAgent peerAgent, int result) {        Log.d(TAG, "onFindPeerAgentResponse : result =" + result);    }    @Override    protected void onServiceConnectionRequested(SAPeerAgent peerAgent) {        if (peerAgent != null) {            acceptServiceConnectionRequest(peerAgent);        }    }    @Override    protected void onServiceConnectionResponse(SAPeerAgent peerAgent, SASocket socket, int result) {        if (result == SAAgent.CONNECTION_SUCCESS) {            if (socket != null) {                mConnectionHandler = (ServiceConnection) socket;            }        } else if (result == SAAgent.CONNECTION_ALREADY_EXIST) {            Log.e(TAG, "onServiceConnectionResponse, CONNECTION_ALREADY_EXIST");        }    }    @Override    protected void onAuthenticationResponse(SAPeerAgent peerAgent, SAAuthenticationToken authToken, int error) {        /*         * The authenticatePeerAgent(peerAgent) API may not be working properly depending on the firmware         * version of accessory device. Please refer to another sample application for Security.         */    }    @Override    protected void onError(SAPeerAgent peerAgent, String errorMessage, int errorCode) {        super.onError(peerAgent, errorMessage, errorCode);    }    private boolean processUnsupportedException(SsdkUnsupportedException e) {        e.printStackTrace();        int errType = e.getType();        if (errType == SsdkUnsupportedException.VENDOR_NOT_SUPPORTED                || errType == SsdkUnsupportedException.DEVICE_NOT_SUPPORTED) {            /*             * Your application can not use Samsung Accessory SDK. You application should work smoothly             * without using this SDK, or you may want to notify user and close your app gracefully (release             * resources, stop Service threads, close UI thread, etc.)             */            stopSelf();        } else if (errType == SsdkUnsupportedException.LIBRARY_NOT_INSTALLED) {            Log.e(TAG, "You need to install Samsung Accessory SDK to use this application.");        } else if (errType == SsdkUnsupportedException.LIBRARY_UPDATE_IS_REQUIRED) {            Log.e(TAG, "You need to update Samsung Accessory SDK to use this application.");        } else if (errType == SsdkUnsupportedException.LIBRARY_UPDATE_IS_RECOMMENDED) {            Log.e(TAG, "We recommend that you update your Samsung Accessory SDK before using this application.");            return false;        }        return true;    }    public class LocalBinder extends Binder {        public ProviderService getService() {            return ProviderService.this;        }    }    public class ServiceConnection extends SASocket {        public ServiceConnection() {            super(ServiceConnection.class.getName());        }        @Override        public void onError(int channelId, String errorMessage, int errorCode) {        }        @Override        public void onReceive(int channelId, byte[] data) {            if (mConnectionHandler == null) {                return;            }            String temp = new String(data);            String[] temp_split = temp.split(":");            String comp = temp_split[0];            Log.i("TEMP", temp);            String command_cnt = "";            String command_id = "";            String command_input = "";            if(temp_split.length >= 3)            {                command_cnt = temp_split[1];                command_id = temp_split[2];                if(temp_split.length >= 4)                    command_input = temp_split[3];            }            try {                //데이터베이스 객체를 얻어오는 다른 간단한 방법                db = openOrCreateDatabase(dbName,  // 데이터베이스파일 이름                        Context.MODE_PRIVATE, // 파일 모드                        null);    // 커서 팩토리                db = helper.getWritableDatabase(); // 읽고 쓸수 있는 DB                //db = helper.getReadableDatabase(); // 읽기 전용 DB select문            } catch (SQLiteException e) {                e.printStackTrace();                Log.e("DD", "데이터베이스를 얻어올 수 없음2");            }            if(comp.equals("START"))            {                Cursor c = db.rawQuery("select * from mytable2;", null);                JSONObject jObject = new JSONObject();                JSONArray jArray = new JSONArray();//배열이 필요할때                while (c.moveToNext())                {                    JSONObject sObject = new JSONObject();//배열 내에 들어갈 json                    int id = c.getInt(0);                    String desc = c.getString(2);                    String option = c.getString(3);                    try {                        sObject.put("id",id);                        sObject.put("description", desc);                        sObject.put("option", option);                        jArray.put(sObject);                    } catch (JSONException e) {                        e.printStackTrace();                    }                    Log.d("DD", "ID : " + id + ", DESCRIPTION : " + desc + ", OPTION : " + option + "    [providerservice]");                }                final String message = "COMMANDLIST|" + jArray.toString();                new Thread(new Runnable() {                    public void run() {                        try {                            mConnectionHandler.send(HELLOACCESSORY_CHANNEL_ID, message.getBytes());                        } catch (IOException e) {                            e.printStackTrace();                        }                    }                }).start();            }            else if(comp.equals("KAKAOMESSAGE"))            {                Log.d("DD", "SELECT");                Cursor c = db.rawQuery("select * from mytable;", null);                JSONObject jObject = new JSONObject();                JSONArray jArray = new JSONArray();//배열이 필요할때                String strToUpdateUI = "";                while (c.moveToNext())                {                    JSONObject sObject = new JSONObject();//배열 내에 들어갈 json                    int id = c.getInt(0);                    String name = c.getString(1);                    try {                        sObject.put("id",id);                        sObject.put("name", name);                        jArray.put(sObject);                    } catch (JSONException e) {                        e.printStackTrace();                    }                    //json 데이터 형식으로 제작                    //strToUpdateUI += Integer.toString(id) + " " + name + "\n";                    Log.d("DD", "SELECT : id:" + id + ", NAME:" + name + "    [providerservice]");                }                //------------------------------------------------------------------------                final String message = "KA|" + jArray.toString();                new Thread(new Runnable() {                    public void run() {                        try {                            mConnectionHandler.send(HELLOACCESSORY_CHANNEL_ID, message.getBytes());                        } catch (IOException e) {                            e.printStackTrace();                        }                    }                }).start();            }            //FACEBOOKMESSAGE, LINEMESAGE 따로 구분해줄 것            else if(comp.equals("COMMAND"))            {                Runtime eee = Runtime.getRuntime();                Log.d("DD", "COMMAND:" + command_cnt + ":" + command_id + ":" + command_input);                String query = "";                // 모든 프로세스 죽이기 - am kill-all                if(command_id.equals("9999")){                    String desc = pref.getValue("9999", "");                    query = "select command from mytable2 where description = '" + desc + "';";                } else if(command_id.equals("8888")){                    String desc = pref.getValue("8888", "");                    query = "select command from mytable2 where description = '"+ desc + "';";                } else {                    query = "select command from mytable2 where id = " + command_id + ";";                }                Log.i("INDEX", query);                // command_input 형식 , 분리                String del_token = ",";                StringTokenizer st = new StringTokenizer(command_input, del_token);                String clip_string = "";                //String query = "select command from mytable2 where id = " + command_id + ";";                Cursor c = db.rawQuery(query, null);                String data_command = "";                while (c.moveToNext()) {                    data_command = c.getString(0);                }                Log.i("commdn", data_command);                for(int jj = 0; jj < Integer.parseInt(command_cnt); jj++){                    Log.i("Command", command_cnt);                    try {                        cmdList.clear();                        for(int ii = 0; ii < commandSplit(data_command); ii++) {                            Log.i("확인", cmdList.get(ii));                            if( cmdList.get(ii).equals("INPUT")){                                // 스트링 토큰으로 클립보드 구분                                clip_string = st.nextToken();                                ClipboardManager clipboardManager =  (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);                                clipboardManager.setText(clip_string);                                try {                                    // 기본 슬립 - 1초                                    Thread.sleep(2000);                                }catch(InterruptedException e){                                    System.out.println(e.getMessage()); //sleep 메소드가 발생하는 InterruptedException                                }                            } else if(cmdList.get(ii).equals("TIME")) {                                // 인자 받아온거 * 1000 해서 sleep안에 넣어주기 인자값                                try {                                    delay_time *= 1000;                                    //Thread.sleep(delay_time);                                    Thread.sleep(delay_time);                                    delay_time = 0;                                }catch(InterruptedException e){                                    System.out.println(e.getMessage()); //sleep 메소드가 발생하는 InterruptedException                                }                            } else if(cmdList.get(ii).equals("PATTERN")){                                long arg1 = 0, arg2 = 0, arg3 = 0;                                // 버퍼 생성                                BufferedReader br = null;                                // Input 스트림 생성                                InputStreamReader isr = null;                                // File Input 스트림 생성                                FileInputStream fis = null;                                File file = new File("/storage/extSdCard/1234/gmacro.txt");                                // 버퍼로 읽어들일 임시 변수                                String temp_str = "";                                // 파일을 읽어들여 File Input 스트림 객체 생성                                fis = new FileInputStream(file);                                // File Input 스트림 객체를 이용해 Input 스트림 객체를 생서하는데 인코딩을 UTF-8로 지정                                isr = new InputStreamReader(fis, "UTF-8");                                // Input 스트림 객체를 이용하여 버퍼를 생성                                br = new BufferedReader(isr);                                String pattern_cmd = "";                                // 한 라인씩 가져오기                                // /dev/input/event2: , 구분자 : 공백, 뒤에 숫자 4개 10진수로 변경                                // 버퍼를 한줄한줄 읽어들여 내용 추출                                pattern_cmd = "adb shell sendevent /dev/input/event2 ";                                while( (temp = br.readLine()) != null) {                                    String del = " ";                                    StringTokenizer temp_token = new StringTokenizer(temp, del);                                    if(temp_token.hasMoreTokens()) {                                        //String check = temp_token.nextToken();                                        if(!temp_token.nextToken().equals("/dev/input/event2:")) {                                            continue;                                        } else {                                            if(temp_token.hasMoreTokens()) {                                                arg1 = Long.parseLong(temp_token.nextToken(), 16);                                            } else continue;                                            if(temp_token.hasMoreTokens()) {                                                arg2 = Long.parseLong(temp_token.nextToken(), 16);                                            } else continue;                                            if(temp_token.hasMoreTokens()) {                                                arg3 = Long.parseLong(temp_token.nextToken(), 16);                                            } else continue;                                            pattern_cmd += String.valueOf(arg1) + " " + String.valueOf(arg2) + " " + String.valueOf(arg3) + " & adb shell sendevent /dev/input/event2 ";                                        }                                    }                                }                                eee.exec(new String[]{"su", "-c", pattern_cmd});                               // 정확한 서식인지 체크                                // 한 라인씩 계속 실행                            } else {                                eee.exec(new String[]{"su", "-c", cmdList.get(ii)});                                try {                                    // 기본 슬립 - 1초                                    Thread.sleep(2000);                                }catch(InterruptedException e){                                    System.out.println(e.getMessage()); //sleep 메소드가 발생하는 InterruptedException                                }                            }                        }                    } catch (IOException e) {                        e.printStackTrace();                    }                }                //매크로 동작 결과                final String message = "COMMANDRESULT|1";                new Thread(new Runnable() {                    public void run() {                        try {                            mConnectionHandler.send(HELLOACCESSORY_CHANNEL_ID, message.getBytes());                        } catch (IOException e) {                            e.printStackTrace();                        }                    }                }).start();            }        }        @Override        protected void onServiceConnectionLost(int reason) {            mConnectionHandler = null;            mHandler.post(new Runnable() {                @Override                public void run() {                }            });        }        public int commandSplit(String cmd){            // 스트링 토큰으로 처음에 타입을 꺼내온다 : 구분자 -> '|'            // type에 따라 인자의 개수가 다르기 떄문에 인자의 개수 만큼 인자도 분리한다 : 구분자 -> '|'            // 이전 커맨드와 다음 커맨드의 구분자 -> ','            String del_token = "|,";            StringTokenizer st = new StringTokenizer(cmd, del_token);            int cmd_cnt = 0;            float x1 = 0, y1 = 0, x2 = 0, y2 = 0;            while(st.hasMoreTokens()) {                switch(st.nextToken()){                    // 터치 이벤트                    case "TOUCH" :                        x1 = Float.parseFloat(st.nextToken());                        y1 = Float.parseFloat(st.nextToken());                        // tap - 터치 이벤트 발생                        String touch_temp = "input tap " + x1 + " " + y1;                        cmdList.add(touch_temp);                        cmd_cnt++;                        break;                    // 롱터치 이벤트                    case "LONGTOUCH" :                        x1 = Float.parseFloat(st.nextToken());                        y1 = Float.parseFloat(st.nextToken());                        x2 = Float.parseFloat(st.nextToken());                        y2 = Float.parseFloat(st.nextToken());                        // swipe - 드래그 이벤트를 통해 롱 터치 이벤트 발생                        String long_temp = "input swipe " + x1 + " " + y1 + " " + x2 + " " + y2 + " 2000";                        cmdList.add(long_temp);                        cmd_cnt++;                        break;                    // 드래그 이벤트                    case "DRAG" :                        x1 = Float.parseFloat(st.nextToken());                        y1 = Float.parseFloat(st.nextToken());                        x2 = Float.parseFloat(st.nextToken());                        y2 = Float.parseFloat(st.nextToken());                        // swipe - 드래그 이벤트 발생                        // input swipe <x1> <y1> <x2> <y2> [duration in milliseconds]                        String drag_temp = "input swipe " + x1 + " " + y1 + " " + x2 + " " + y2 + " 300";                        cmdList.add(drag_temp);                        cmd_cnt++;                        break;                    // 시간 이벤트                    case "TIME" :                        delay_time = Integer.parseInt(st.nextToken());                        cmdList.add("TIME");                        cmd_cnt++;                        break;                    case "INPUT" :                        cmdList.add("INPUT");                        cmd_cnt++;                        break;                    case "SCREEN" :                        cmdList.add("input keyevent 120");                        cmd_cnt++;                        break;                    case "HOMEKEY" :                        cmdList.add("input keyevent 3");                        cmd_cnt++;                        break;                    case "BACKKEY" :                        cmdList.add("input keyevent 4");                        cmd_cnt++;                        break;                    case "POWERKEY" :                        cmdList.add("input keyevent 26");                        cmd_cnt++;                        break;                    case "VOLUP" :                        cmdList.add("input keyevent 24");                        cmd_cnt++;                        break;                    case "VOLDOWN" :                        cmdList.add("input keyevent 25");                        cmd_cnt++;                        break;                    case "MUGICSTART" :                        cmdList.add("input keyevent 85");                        cmd_cnt++;                        break;                    case "MUGICEND" :                        cmdList.add("input keyevent 86");                        cmd_cnt++;                        break;                    case "MUGICNEXT" :                        cmdList.add("input keyevent 87");                        cmd_cnt++;                        break;                    case "MUGICRESTART" :                        cmdList.add("input keyevent 88");                        cmd_cnt++;                        break;                    case "MUGICSTOP" :                        cmdList.add("input keyevent 79");                        cmd_cnt++;                        break;                    case "PATTERN" :                        cmdList.add("PATTERN");                        cmd_cnt++;                        break;                    case "PROCESSRUN" :                        String packageName = st.nextToken();                        String className = st.nextToken();                        String cmd_run_str = "am start -n " + packageName + "/" + className;                        cmdList.add(cmd_run_str);                        cmd_cnt++;                        break;                    case "PROCESSKILL" :                        packageName = st.nextToken();                        Log.i("로그확인", packageName);                        String cmd_kill_str = "am force-stop " + packageName;                        cmdList.add(cmd_kill_str);                        cmd_cnt++;                        break;                }            }            return cmd_cnt;        }    }    void allKillRunningApps()	{        ActivityManager activity_manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);        List<ActivityManager.RunningAppProcessInfo> app_list = activity_manager.getRunningAppProcesses();        for(int i=0; i<app_list.size(); i++)	{            activity_manager.killBackgroundProcesses(app_list.get(i).processName);            Log.i("프로세스", "if문 전");            if("com.getpackagelist.app".equals(app_list.get(i).processName) == false && "com.samsung.accessory:systemprovider".equals(app_list.get(i).processName) == false) {                Log.i("프로세스", app_list.get(i).processName + "종료시킵니다.");                try {                    Runtime.getRuntime().exec(new String[]{"su", "-c", "kill " + app_list.get(i).pid});                } catch (IOException e) {                    e.printStackTrace();                }            }        }        System.gc();    }}//2b1f4edc// adb -s 2b1f4edc shell input touchscreen swipe 356.0 1273.0 1120.0 2025.0 & adb -s 2b1f4edc shell input swipe 1097.0 2052.0 718.0 2034.0// adb -s 2b1f4edc shell input swipe 1097.0 2052.0 718.0 2034.0 100